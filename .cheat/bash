# script current directory no matter where it's called from
DIR=$(cd `dirname $0` && pwd)

# error mesage function
errorMsg() {
    echo "$*" 1>&2
}

# run script and ensure we exit on failure
bash -eou pipefail <script>

# To implement a for loop:
for file in *;
do
    echo $file found;
done

# To implement a case command:
case "$1"
in
    0) echo "zero found";;
    1) echo "one found";;
    2) echo "two found";;
    3*) echo "something beginning with 3 found";;
esac

# Turn on debugging:
set -x

# Turn off debugging:
set +x

# Retrieve N-th piped command exit status
printf 'foo' | fgrep 'foo' | sed 's/foo/bar/'
echo ${PIPESTATUS[0]}  # replace 0 with N

# Lock file:
( set -o noclobber; echo > my.lock ) || echo 'Failed to create lock file'

# log all output to file from within a script
LOG="/tmp/someScript.log"
exec >  >(tee -ia $LOG)
exec 2> >(tee -ia $LOG >&2)

# misc
die() { echo $* 1>&2 ; exit 1 ; }
TIMESTAMP=$(date +%Y-%m-%d-%H%M)
FILE_DATE=$(date +%Y-%m-%d)

# terminal colours
for i in {0..255}; do
    printf "\x1b[38;5;${i}mcolour${i}\x1b[0m\n"
done

# or
for x in {0..8}; do 
    for i in {30..37}; do 
        for a in {40..47}; do 
            echo -ne "\e[$x;$i;$a""m\\\e[$x;$i;$a""m\e[0;37;40m "
        done
        echo
    done
done
echo ""

# save multiline string to var
read -r -d'\0' USAGE <<EOF # 'EOF' = don't expand variables, <<-EOF = remove tab indents
USAGE:                     # -d'\0' fixes the scripts that use 'set -euo pipefail' failing silently , ensure you put \0 at and
    ...

The End\\0
EOF
echo "$USAGE"
